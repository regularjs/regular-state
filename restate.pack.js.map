{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 9b6cc0dcf4894924ff56","webpack:///./src/index.js","webpack:///./src/client.js","webpack:///external \"Regular\"","webpack:///./~/stateman/src/index.js","webpack:///./~/stateman/src/manager/client.js","webpack:///./~/stateman/src/state.js","webpack:///./~/stateman/src/util.js","webpack:///./~/stateman/src/history.js","webpack:///./~/stateman/src/browser.js","webpack:///./~/stateman/src/manager/base.js","webpack:///./~/stateman/src/manager/server.js","webpack:///./src/util.js","webpack:///./src/base.js","webpack:///./src/extension.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;ACpCA;;;;;;;;;;;;ACEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA6B;AAC7B;AACA,YAAW;AACX,UAAS;AACT;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;;;AAGA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;;;;;;;;;AC5KA,gD;;;;;;ACAA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;;;AAGA;;AAEA;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,0CAAyC,8BAA8B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;;AAEA;;AAEA;;AAEA;AACA,+D;AACA;AACA;AACA;AACA,Q;AACA;;AAEA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAwC,gBAAgB;;AAExD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAuB,sCAAsC;AAC7D;;AAEA;;AAEA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,wCAAuC,aAAa;AACpD;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK;AACL;;;AAGA;AACA,MAAK;AACL;AACA;;AAEA;;;;AAIA,+DAA8D,iBAAiB;;;AAG/E;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,6CAA4C,YAAY;AACxD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,0CAAyC,aAAa;;AAEtD;;AAEA;;AAEA,U;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA,UAAS;;AAET,QAAO;;;AAGP,MAAK;AACL;;AAEA;;AAEA;;AAEA;;AAEA,qBAAoB,SAAS;AAC7B;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,UAAS;;AAET,QAAO;;AAEP,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6EAA4E,wBAAwB,EAAE;;AAEtG;;;AAGA;AACA;;AAEA;;AAEA;;AAEA,UAAS;;AAET;AACA;;AAEA;;AAEA;;AAEA,QAAO;;AAEP;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,kD;;AAEA;;AAEA;AACA;;AAEA,MAAK;;;AAGL;;AAEA,gD;AACA;AACA;AACA,qB;AACA,QAAO;;AAEP,MAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;;AAEA;;AAEA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA,sBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,EAAC;;AAED;;;;;;;ACnZA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP,wCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;;AAEH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,8CAA6C,iBAAiB;AAC9D,IAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA,oCAAmC,MAAM;AACzC;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;;AAEA,EAAC;;AAED;;;;;;;ACpKA;AACA,kCAAiC;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,4BAA2B;AAC3B;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT,8CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA,4BAA2B;;AAE3B;AACA;;AAEA;AACA,0CAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAoB;;AAEpB;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA0C,GAAG;AAC7C;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,iEAAgE,GAAG;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,U;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iEAAgE;AAChE;;AAEA;;AAEA;;AAEA;;AAEA;;;;;;;;ACnMA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,gCAA+B,iBAAiB;AAChD,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,sCAAqC,aAAa;AAClD;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,MAAK;AACL;AACA;AACA,IAAG;;AAEH;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,4DAA2D;AAC3D,IAAG;AACH;AACA;AACA;AACA;AACA,+BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAC;;AAED;;;;;;;AC1NA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA,8BAA6B;AAC7B,8BAA6B,2CAA2C;;AAExE;AACA,8BAA6B;AAC7B,8BAA6B;AAC7B;;;;;;;;ACvBA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gE;AACA,MAAK;;;AAGL;;AAEA,6CAA4C,aAAa,EAAE;;AAE3D,MAAK;;AAEL;;AAEA;AACA;AACA;AACA,sBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;;AAEA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,uBAAsB,SAAS;;AAE/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL,EAAC;;AAED;;;;;;;;;ACzIA;AACA;;AAEA;AACA,+CAA8C,mCAAmC;AACjF;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAC;;;AAGD,+B;;;;;;;ACtCA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA,kBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;;;;;AAKA,uB;;;;;;AChDA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,sBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;;;;;AAKA;;;;;;;;AClEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAa,IAAI,WAAW;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA,QAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,IAAG;AACH","file":"restate.pack.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"Regular\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"Regular\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"restate\"] = factory(require(\"Regular\"));\n\telse\n\t\troot[\"restate\"] = factory(root[\"Regular\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 9b6cc0dcf4894924ff56\n **/","\n\nmodule.exports = require('./client');\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/index.js\n ** module id = 0\n ** module chunks = 0\n **/","\n\n\n\nvar Regular = require('regularjs');\nvar Stateman = require('stateman');\nvar _ = require('./util');\nvar dom =Regular.dom;\n\nvar createRestate = require('./base');\n\nvar Restate = createRestate( Stateman );\nvar so = Restate.prototype;\n\n\nvar oldStateFn = so.state;\nvar oldStart = so.start;\n\n\nso.start = function(options, callback){\n  var self = this;\n  options = options || {};\n  var ssr = options.ssr;\n  var view = options.view;\n  this.view = view;\n  // prevent default stateman autoLink feature \n  options.autolink = false;\n  if(ssr) {\n    // wont fix .\n    options.autofix = false;\n    options.html5 = true;\n  }\n  // delete unused options of stateman\n  delete options.ssr;\n  delete options.view;\n  if( options.html5 && window.history && \"onpopstate\" in window ){\n    this.ssr = ssr;\n    dom.on( document.body, \"click\", function(ev){\n      var target = ev.target, href;\n      if(target.getAttribute('data-autolink') != null){\n        ev.preventDefault();\n        href = dom.attr(target, 'href');\n        self.nav(href);\n      }\n    });\n  }\n  oldStart.call(this, options, callback)\n  return this;\n}\n\nso.state = function(name, config){\n  var manager = this;\n  var oldConfig;\n  if( typeof name === 'string'){\n    if(!config) return oldStateFn.call(this, name)\n    oldConfig = config;\n\n    // 不代理canEnter事件, 因为此时component还不存在\n    // mount (if not installed, install first)\n    \n    // 1. .Null => a.b.c\n    // canEnter a  -> canEnter a.b -> canEnter a.b.c -> \n    //  -> install a ->enter a -> mount a \n    //  -> install a.b -> enter a.b -> mount a.b \n    //  -> install a.b.c -> enter a.b.c -> mount a.b.c\n\n\n    // 2. update a.b.c\n    // -> install a -> mount a \n    // -> install a.b -> mount a.b \n    // -> install a.b.c -> mount a.b.c\n\n    // 3. a.b.c -> a.b.d\n    // canLeave c -> canEnter d -> leave c \n    //  -> install a -> mount a -> \n    //  -> install b -> mount b -> \n    //  -> install d -> enter d -> mount d\n\n    function install( option , isEnter){\n      var component = this.component;\n      var parent = this.parent;\n      var self = this;\n      var ssr = option.ssr = isEnter && option.firstTime && manager.ssr && this.ssr !== false;\n\n      var installOption = {\n        ssr: ssr,\n        state: this,\n        param: option.param,\n        component: component,\n        originOption: option\n      }\n      var installPromise = manager.install( installOption ).then( function( installed ){\n\n        var globalView = manager.view, view, ret;\n        var Component = installed.Component;\n        var needComponent = !component || component.constructor !== Component;\n\n        if(parent.component){\n          view = parent.component.$viewport;\n        }else{\n          view = globalView;\n        }\n\n        // if(!view) throw Error('need viewport for ' + self.name );\n\n        if( needComponent ){\n          // 这里需要给出提示\n          if(component) component.destroy();\n          var mountNode = ssr && view;\n\n          component = self.component = new Component({\n            mountNode: mountNode,\n            data: _.extend({}, installed.data),\n            $state: manager\n          })\n        }else{\n          _.extend( component.data, installed.data, true)\n        }\n        if( (needComponent && !mountNode) || (!needComponent && isEnter) ) component.$inject(view);\n        return component;\n      })\n      if(isEnter){\n        installPromise = installPromise.then(function(){\n          return _.proxyMethod(self.component, 'enter', option)\n        })\n      }\n      return installPromise.then( self.mount.bind( self, option ) ).then(function(){\n        self.component.$update(function(){\n          self.component.$mute(false)\n        });\n      })\n    }\n\n\n    config = {\n      component: null,\n      install: install,\n      mount: function( option ){\n        return _.proxyMethod(this.component, 'mount', option)\n      },\n      canEnter: function(option){\n        return _.proxyMethod(this, oldConfig.canEnter, option )\n      },\n      canLeave: function(option){\n        return _.proxyMethod(this.component, 'canEnter', option)\n      },\n      update: function(option){\n        return this.install(option, false);\n      },\n      enter: function(option){\n        return this.install(option, true);\n      },\n      leave: function( option ){\n        var component = this.component;\n        if(!component) return;\n\n        return Promise.resolve().then(function(){\n          return _.proxyMethod(component, 'leave', option)\n        }).then(function(){\n          component.$inject(false);\n          component.$mute(true);\n        })\n      }\n    }\n    _.extend(config, oldConfig, true)\n    \n  }\n  return oldStateFn.call(this, name, config)    \n}\n\n\n\nmodule.exports = Restate;\n\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/client.js\n ** module id = 1\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"Regular\"\n ** module id = 2\n ** module chunks = 0\n **/","var stateman;\n\nif( typeof window === 'object' ){\n  stateman = require(\"./manager/client.js\");\n  stateman.History = require(\"./history.js\");\n  stateman.util = require(\"./util.js\");\n  stateman.isServer = false;\n}else{\n  stateman = require(\"./manager/server.js\");\n  stateman.isServer = true;\n}\n\n\nstateman.State = require(\"./state.js\");\n\nmodule.exports = stateman;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/stateman/src/index.js\n ** module id = 3\n ** module chunks = 0\n **/","\nvar State = require(\"../state.js\"),\n  History = require(\"../history.js\"),\n  Base = require(\"./base.js\"),\n  _ = require(\"../util.js\"),\n  baseTitle = document.title,\n  stateFn = State.prototype.state;\n\nfunction StateMan(options){\n\n  if(this instanceof StateMan === false){ return new StateMan(options); }\n  options = options || {};\n  Base.call(this, options);\n  if(options.history) this.history = options.history;\n  this._stashCallback = [];\n  this.current = this.active = this;\n  // auto update document.title, when navigation has been down\n  this.on(\"end\", function( options ){\n    var cur = this.current;\n    document.title = cur.getTitle( options ) ||  baseTitle  ;\n  });\n}\n\nvar o =_.inherit( StateMan, Base.prototype );\n\n_.extend(o , {\n\n    start: function(options, callback){\n\n      this._startCallback = callback;\n      if( !this.history ) this.history = new History(options); \n      if( !this.history.isStart ){\n        this.history.on(\"change\", _.bind(this._afterPathChange, this));\n        this.history.start();\n      } \n      return this;\n\n    },\n    stop: function(){\n      this.history.stop();\n    },\n    // @TODO direct go the point state\n    go: function(state, option, callback){\n      option = option || {};\n      var statename;\n      if(typeof state === \"string\") {\n         statename = state;\n         state = this.state(state);\n      }\n\n      if(!state) return this._notfound({state:statename});\n\n      if(typeof option === \"function\"){\n        callback = option;\n        option = {};\n      }\n\n      if(option.encode !== false){\n        var url = state.encode(option.param);\n        option.path = url;\n        this.nav(url, {silent: true, replace: option.replace});\n      }\n\n      this._go(state, option, callback);\n\n      return this;\n    },\n    nav: function(url, options, callback){\n      if(typeof options === \"function\"){\n        callback = options;\n        options = {};\n      }\n      options = options || {};\n\n      options.path = url;\n\n      this.history.nav( url, _.extend({silent: true}, options));\n      if(!options.silent) this._afterPathChange( _.cleanPath(url) , options , callback);\n\n      return this;\n    },\n\n    // after pathchange changed\n    // @TODO: afterPathChange need based on decode\n    _afterPathChange: function(path, options ,callback){\n\n      this.emit(\"history:change\", path);\n\n      var found = this.decode(path);\n\n      options = options || {};\n\n      options.path = path;\n\n      if(!found){\n        return this._notfound(options);\n      }\n\n      options.param = found.param;\n\n      if( options.firstTime && !callback){\n        callback =  this._startCallback;\n        delete this._startCallback;\n      }\n\n      this._go( found.state, options, callback );\n    },\n    _notfound: function(options){\n\n\n      return this.emit(\"notfound\", options);\n    },\n    // goto the state with some option\n    _go: function(state, option, callback){\n\n      var over;\n\n  \n\n      if(state.hasNext && this.strict) return this._notfound({name: state.name});\n\n  \n      option.param = option.param || {};\n\n      var current = this.current,\n        baseState = this._findBase(current, state),\n        prepath = this.path,\n        self = this;\n\n\n      if( typeof callback === \"function\" ) this._stashCallback.push(callback);\n      // if we done the navigating when start\n      function done(success){\n        over = true;\n        if( success !== false ) self.emit(\"end\", option);\n        self.pending = null;\n        self._popStash(option);\n      }\n      \n      option.previous = current;\n      option.current = state;\n\n      if(current !== state){\n        option.stop = function(){\n          done(false);\n          self.nav( prepath? prepath: \"/\", {silent:true});\n        };\n        self.emit(\"begin\", option);\n\n      }\n      // if we stop it in 'begin' listener\n      if(over === true) return;\n\n      option.phase = 'permission';\n      this._walk(current, state, option, true , _.bind( function( notRejected ){\n\n        if( notRejected===false ){\n          // if reject in callForPermission, we will return to old \n          prepath && this.nav( prepath, {silent: true});\n\n          done(false, 2);\n\n          return this.emit('abort', option);\n\n        } \n\n        // stop previous pending.\n        if(this.pending) this.pending.stop();\n        this.pending = option;\n        this.path = option.path;\n        this.current = option.current;\n        this.param = option.param;\n        this.previous = option.previous;\n        option.phase = 'navigation';\n        this._walk(current, state, option, false, _.bind(function( notRejected ){\n\n          if( notRejected === false ){\n            this.current = this.active;\n            done(false);\n            return this.emit('abort', option);\n          }\n\n\n          this.active = option.current;\n\n          option.phase = 'completion';\n          return done();\n\n        }, this) );\n\n      }, this) );\n\n\n    },\n    _popStash: function(option){\n\n      var stash = this._stashCallback, len = stash.length;\n\n      this._stashCallback = [];\n\n      if(!len) return;\n\n      for(var i = 0; i < len; i++){\n        stash[i].call(this, option);\n      }\n    },\n\n    // the transition logic  Used in Both canLeave canEnter && leave enter LifeCycle\n\n    _walk: function(from, to, option, callForPermit , callback){\n      // if(from === to) return callback();\n\n      // nothing -> app.state\n      var parent = this._findBase(from , to);\n      var self = this;\n\n\n      option.backward = true;\n      this._transit( from, parent, option, callForPermit , function( notRejected ){\n\n        if( notRejected === false ) return callback( notRejected );\n\n        // only actual transiton need update base state;\n        option.backward = false;\n        self._walkUpdate(self, parent, option, callForPermit, function(notRejected){\n          if(notRejected === false) return callback(notRejected);\n\n          self._transit( parent, to, option, callForPermit,  callback);\n\n        });\n\n      });\n\n    },\n\n    _transit: function(from, to, option, callForPermit, callback){\n      //  touch the ending\n      if( from === to ) return callback();\n\n      var back = from.name.length > to.name.length;\n      var method = back? 'leave': 'enter';\n      var applied;\n\n      // use canEnter to detect permission\n      if( callForPermit) method = 'can' + method.replace(/^\\w/, function(a){ return a.toUpperCase(); });\n\n      var loop = _.bind(function( notRejected ){\n\n\n        // stop transition or touch the end\n        if( applied === to || notRejected === false ) return callback(notRejected);\n\n        if( !applied ) {\n\n          applied = back? from : this._computeNext(from, to);\n\n        }else{\n\n          applied = this._computeNext(applied, to);\n        }\n\n        if( (back && applied === to) || !applied )return callback( notRejected );\n\n        this._moveOn( applied, method, option, loop );\n\n      }, this);\n\n      loop();\n    },\n\n    _moveOn: function( applied, method, option, callback){\n\n      var isDone = false;\n      var isPending = false;\n\n      option.async = function(){\n\n        isPending = true;\n\n        return done;\n      };\n\n      function done( notRejected ){\n        if( isDone ) return;\n        isPending = false;\n        isDone = true;\n        callback( notRejected );\n      }\n\n      option.stop = function(){\n        done( false );\n      };\n\n\n      this.active = applied;\n      var retValue = applied[method]? applied[method]( option ): true;\n\n      if(method === 'enter') applied.visited = true;\n      // promise\n      // need breadk , if we call option.stop first;\n\n      if( _.isPromise(retValue) ){\n\n        return this._wrapPromise(retValue, done); \n\n      }\n\n      // if haven't call option.async yet\n      if( !isPending ) done( retValue );\n\n    },\n\n\n    _wrapPromise: function( promise, next ){\n\n      return promise.then( next, function(err){ \n        //TODO: 万一promise中throw了Error如何处理？\n        if(err instanceof Error) throw err;\n        next(false); \n      }) ;\n\n    },\n\n    _computeNext: function( from, to ){\n\n      var fname = from.name;\n      var tname = to.name;\n\n      var tsplit = tname.split('.');\n      var fsplit = fname.split('.');\n\n      var tlen = tsplit.length;\n      var flen = fsplit.length;\n\n      if(fname === '') flen = 0;\n      if(tname === '') tlen = 0;\n\n      if( flen < tlen ){\n        fsplit[flen] = tsplit[flen];\n      }else{\n        fsplit.pop();\n      }\n\n      return this.state(fsplit.join('.'));\n\n    },\n\n    _findQuery: function(querystr){\n\n      var queries = querystr && querystr.split(\"&\"), query= {};\n      if(queries){\n        var len = queries.length;\n        for(var i =0; i< len; i++){\n          var tmp = queries[i].split(\"=\");\n          query[tmp[0]] = tmp[1];\n        }\n      }\n      return query;\n\n    },\n\n    _sortState: function( a, b ){\n      return ( b.priority || 0 ) - ( a.priority || 0 );\n    },\n    // find the same branch;\n    _findBase: function(now, before){\n\n      if(!now || !before || now == this || before == this) return this;\n      var np = now, bp = before, tmp;\n      while(np && bp){\n        tmp = bp;\n        while(tmp){\n          if(np === tmp) return tmp;\n          tmp = tmp.parent;\n        }\n        np = np.parent;\n      }\n    },\n    // check the query and Param\n    _walkUpdate: function(baseState, to, options, callForPermit,  done){\n\n      var method = callForPermit? 'canUpdate': 'update';\n      var from = baseState;\n      var self = this;\n\n      var pathes = [], node = to;\n      while(node !== this){\n        pathes.push( node );\n        node = node.parent;\n      }\n\n      var loop = function( notRejected ){\n        if( notRejected === false ) return done( false );\n        if( !pathes.length ) return done();\n        from = pathes.pop();\n        self._moveOn( from, method, options, loop )\n      }\n\n      self._moveOn( from, method, options, loop )\n    }\n\n}, true);\n\nmodule.exports = StateMan;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/stateman/src/manager/client.js\n ** module id = 4\n ** module chunks = 0\n **/","var _ = require(\"./util.js\");\n\nfunction State(option){\n  this._states = {};\n  this._pending = false;\n  this.visited = false;\n  if(option) this.config(option);\n}\n\n\n//regexp cache\nState.rCache = {};\n\n_.extend( _.emitable( State ), {\n\n  getTitle: function(options){\n    var cur = this ,title;\n    while( cur ){\n      title = cur.title;\n      if(title) return typeof title === 'function'? cur.title(options): cur.title\n      cur = cur.parent;\n    }\n    return title;\n  },\n\n\n  state: function(stateName, config){\n    if(_.typeOf(stateName) === \"object\"){\n      var keys = _.values(stateName, true);\n      keys.sort(function(ka, kb){\n        return _.countDot(ka) - _.countDot(kb);\n      });\n\n      for(var i = 0, len = keys.length; i< len ;i++){\n        var key = keys[i];\n        this.state(key, stateName[key])\n      }\n      return this;\n    }\n    var current = this, next, nextName, states = this._states, i=0;\n\n    if( typeof stateName === \"string\" ) stateName = stateName.split(\".\");\n\n    var slen = stateName.length;\n    var stack = [];\n\n    do{\n      nextName = stateName[i];\n      next = states[nextName];\n      stack.push(nextName);\n      if(!next){\n        if(!config) return;\n        next = states[nextName] = new State();\n        _.extend(next, {\n          parent: current,\n          manager: current.manager || current,\n          name: stack.join(\".\"),\n          currentName: nextName\n        });\n        current.hasNext = true;\n        next.configUrl();\n      }\n      current = next;\n      states = next._states;\n    }while((++i) < slen )\n\n    if(config){\n       next.config(config);\n       return this;\n    } else {\n      return current;\n    }\n  },\n\n  config: function(configure){\n\n    configure = this._getConfig(configure);\n\n    for(var i in configure){\n      var prop = configure[i];\n      switch(i){\n        case \"url\":\n          if(typeof prop === \"string\"){\n            this.url = prop;\n            this.configUrl();\n          }\n          break;\n        case \"events\":\n          this.on(prop);\n          break;\n        default:\n          this[i] = prop;\n      }\n    }\n  },\n\n  // children override\n  _getConfig: function(configure){\n    return typeof configure === \"function\"? {enter: configure} : configure;\n  },\n\n  //from url\n  configUrl: function(){\n    var url = \"\" , base = this;\n\n    while( base ){\n\n      url = (typeof base.url === \"string\" ? base.url: (base.currentName || \"\")) + \"/\" + url;\n\n      // means absolute;\n      if(url.indexOf(\"^/\") === 0) {\n        url = url.slice(1);\n        break;\n      }\n      base = base.parent;\n    }\n    this.pattern = _.cleanPath(\"/\" + url);\n    var pathAndQuery = this.pattern.split(\"?\");\n    this.pattern = pathAndQuery[0];\n    // some Query we need watched\n\n    _.extend(this, _.normalize(this.pattern), true);\n  },\n  encode: function(param){\n    var state = this;\n    param = param || {};\n\n    var matched = \"%\";\n\n    var url = state.matches.replace(/\\(([\\w-]+)\\)/g, function(all, capture){\n      var sec = param[capture] || \"\";\n      matched+= capture + \"%\";\n      return sec;\n    }) + \"?\";\n\n    // remained is the query, we need concat them after url as query\n    for(var i in param) {\n      if( matched.indexOf(\"%\"+i+\"%\") === -1) url += i + \"=\" + param[i] + \"&\";\n    }\n    return _.cleanPath( url.replace(/(?:\\?|&)$/,\"\") );\n  },\n  decode: function( path ){\n    var matched = this.regexp.exec(path),\n      keys = this.keys;\n\n    if(matched){\n\n      var param = {};\n      for(var i =0,len=keys.length;i<len;i++){\n        param[keys[i]] = matched[i+1];\n      }\n      return param;\n    }else{\n      return false;\n    }\n  },\n  // by default, all lifecycle is permitted\n\n  async: function(){\n    throw new Error( 'please use option.async instead');\n  }\n\n});\n\nmodule.exports = State;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/stateman/src/state.js\n ** module id = 5\n ** module chunks = 0\n **/","var _ = module.exports = {};\nvar slice = [].slice, o2str = ({}).toString;\n\n// merge o2's properties to Object o1. \n_.extend = function(o1, o2, override){\n  for(var i in o2) if(override || o1[i] === undefined){\n    o1[i] = o2[i];\n  }\n  return o1;\n};\n\nvar rDot = /\\./g;\n_.countDot = function(word){\n  var ret = word.match(rDot)\n  return ret? ret.length: 0;\n}\n\n_.values = function( o, key){\n  var keys = [];\n  for(var i in o) if( o.hasOwnProperty(i) ){\n    keys.push( key? i: o[i] );\n  }\n  return keys;\n};\n\n_.inherit = function( cstor, o ){\n  function Faker(){}\n  Faker.prototype = o;\n  cstor.prototype = new Faker();\n  cstor.prototype.constructor = cstor;\n  return o;\n}\n\n_.slice = function(arr, index){\n  return slice.call(arr, index);\n};\n\n_.typeOf = function typeOf (o) {\n  return o == null ? String(o) : o2str.call(o).slice(8, -1).toLowerCase();\n};\n\n//strict eql\n_.eql = function(o1, o2){\n  var t1 = _.typeOf(o1), t2 = _.typeOf(o2);\n  if( t1 !== t2) return false;\n  if(t1 === 'object'){\n    // only check the first's properties\n    for(var i in o1){\n      // Immediately return if a mismatch is found.\n      if( o1[i] !== o2[i] ) return false;\n    }\n    return true;\n  }\n  return o1 === o2;\n};\n\n// small emitter \n_.emitable = (function(){\n  function norm(ev){\n    var eventAndNamespace = (ev||'').split(':');\n    return {event: eventAndNamespace[0], namespace: eventAndNamespace[1]};\n  }\n  var API = {\n    once: function(event, fn){\n      var callback = function(){\n        fn.apply(this, arguments);\n        this.off(event, callback);\n      };\n      return this.on(event, callback);\n    },\n    on: function(event, fn) {\n      if(typeof event === 'object'){\n        for (var i in event) {\n          this.on(i, event[i]);\n        }\n        return this;\n      }\n      var ne = norm(event);\n      event=ne.event;\n      if(event && typeof fn === 'function' ){\n        var handles = this._handles || (this._handles = {}),\n          calls = handles[event] || (handles[event] = []);\n        fn._ns = ne.namespace;\n        calls.push(fn);\n      }\n      return this;\n    },\n    off: function(event, fn) {\n      var ne = norm(event); event = ne.event;\n      if(!event || !this._handles) this._handles = {};\n\n      var handles = this._handles;\n      var calls = handles[event];\n\n      if (calls) {\n        if (!fn && !ne.namespace) {\n          handles[event] = [];\n        }else{\n          for (var i = 0, len = calls.length; i < len; i++) {\n            if ( (!fn || fn === calls[i]) && (!ne.namespace || calls[i]._ns === ne.namespace) ) {\n              calls.splice(i, 1);\n              return this;\n            }\n          }\n        }\n      }\n\n      return this;\n    },\n    emit: function(event){\n      var ne = norm(event); event = ne.event;\n\n      var args = _.slice(arguments, 1),\n        handles = this._handles, calls;\n\n      if (!handles || !(calls = handles[event])) return this;\n      for (var i = 0, len = calls.length; i < len; i++) {\n        var fn = calls[i];\n        if( !ne.namespace || fn._ns === ne.namespace ) fn.apply(this, args);\n      }\n      return this;\n    }\n  };\n  return function(obj){\n      obj = typeof obj == \"function\" ? obj.prototype : obj;\n      return _.extend(obj, API);\n  };\n})();\n\n_.bind = function(fn, context){\n  return function(){\n    return fn.apply(context, arguments);\n  };\n};\n\nvar rDbSlash = /\\/+/g, // double slash\n  rEndSlash = /\\/$/;    // end slash\n\n_.cleanPath = function (path){\n  return (\"/\" + path).replace( rDbSlash,\"/\" ).replace( rEndSlash, \"\" ) || \"/\";\n};\n\n// normalize the path\nfunction normalizePath(path) {\n  // means is from \n  // (?:\\:([\\w-]+))?(?:\\(([^\\/]+?)\\))|(\\*{2,})|(\\*(?!\\*)))/g\n  var preIndex = 0;\n  var keys = [];\n  var index = 0;\n  var matches = \"\";\n\n  path = _.cleanPath(path);\n\n  var regStr = path\n    //  :id(capture)? | (capture)   |  ** | * \n    .replace(/\\:([\\w-]+)(?:\\(([^\\/]+?)\\))?|(?:\\(([^\\/]+)\\))|(\\*{2,})|(\\*(?!\\*))/g, \n      function(all, key, keyformat, capture, mwild, swild, startAt) {\n        // move the uncaptured fragment in the path\n        if(startAt > preIndex) matches += path.slice(preIndex, startAt);\n        preIndex = startAt + all.length;\n        if( key ){\n          matches += \"(\" + key + \")\";\n          keys.push(key);\n          return \"(\"+( keyformat || \"[\\\\w-]+\")+\")\";\n        }\n        matches += \"(\" + index + \")\";\n\n        keys.push( index++ );\n\n        if( capture ){\n           // sub capture detect\n          return \"(\" + capture +  \")\";\n        } \n        if(mwild) return \"(.*)\";\n        if(swild) return \"([^\\\\/]*)\";\n    });\n\n  if(preIndex !== path.length) matches += path.slice(preIndex);\n\n  return {\n    regexp: new RegExp(\"^\" + regStr +\"/?$\"),\n    keys: keys,\n    matches: matches || path\n  };\n}\n\n_.log = function(msg, type){\n  typeof console !== \"undefined\" && console[type || \"log\"](msg); //eslint-disable-line no-console\n};\n\n_.isPromise = function( obj ){\n\n  return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';\n\n};\n\n_.normalize = normalizePath;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/stateman/src/util.js\n ** module id = 6\n ** module chunks = 0\n **/","\n// MIT\n// Thx Backbone.js 1.1.2  and https://github.com/cowboy/jquery-hashchange/blob/master/jquery.ba-hashchange.js\n// for iframe patches in old ie.\n\nvar browser = require(\"./browser.js\");\nvar _ = require(\"./util.js\");\n\n\n// the mode const\nvar QUIRK = 3,\n  HASH = 1,\n  HISTORY = 2;\n\n// extract History for test\n// resolve the conficlt with the Native History\nfunction History(options){\n  options = options || {};\n\n  // Trick from backbone.history for anchor-faked testcase\n  this.location = options.location || browser.location;\n\n  // mode config, you can pass absolute mode (just for test);\n  this.html5 = options.html5;\n  this.mode = options.html5 && browser.history ? HISTORY: HASH;\n  if( !browser.hash ) this.mode = QUIRK;\n  if(options.mode) this.mode = options.mode;\n\n  // hash prefix , used for hash or quirk mode\n  this.prefix = \"#\" + (options.prefix || \"\") ;\n  this.rPrefix = new RegExp(this.prefix + '(.*)$');\n  this.interval = options.interval || 66;\n\n  // the root regexp for remove the root for the path. used in History mode\n  this.root = options.root ||  \"/\" ;\n  this.rRoot = new RegExp(\"^\" +  this.root);\n\n\n  this.autolink = options.autolink!==false;\n  this.autofix = options.autofix!==false;\n\n  this.curPath = undefined;\n}\n\n_.extend( _.emitable(History), {\n  // check the\n  start: function(callback){\n    var path = this.getPath();\n    this._checkPath = _.bind(this.checkPath, this);\n\n    if( this.isStart ) return;\n    this.isStart = true;\n\n    if(this.mode === QUIRK){\n      this._fixHashProbelm(path);\n    }\n\n    switch ( this.mode ){\n      case HASH:\n        browser.on(window, \"hashchange\", this._checkPath);\n        break;\n      case HISTORY:\n        browser.on(window, \"popstate\", this._checkPath);\n        break;\n      case QUIRK:\n        this._checkLoop();\n    }\n    // event delegate\n    this.autolink && this._autolink();\n    this.autofix && this._fixInitState();\n\n    this.curPath = path;\n\n    this.emit(\"change\", path, { firstTime: true});\n  },\n\n  // the history teardown\n  stop: function(){\n\n    browser.off(window, 'hashchange', this._checkPath);\n    browser.off(window, 'popstate', this._checkPath);\n    clearTimeout(this.tid);\n    this.isStart = false;\n    this._checkPath = null;\n  },\n\n  // get the path modify\n  checkPath: function(/*ev*/){\n\n    var path = this.getPath(), curPath = this.curPath;\n\n    //for oldIE hash history issue\n    if(path === curPath && this.iframe){\n      path = this.getPath(this.iframe.location);\n    }\n\n    if( path !== curPath ) {\n      this.iframe && this.nav(path, {silent: true});\n      this.curPath = path;\n      this.emit('change', path);\n    }\n  },\n\n  // get the current path\n  getPath: function(location){\n    location = location || this.location;\n    var tmp;\n\n    if( this.mode !== HISTORY ){\n      tmp = location.href.match(this.rPrefix);\n      return _.cleanPath(tmp && tmp[1]? tmp[1]: \"\");\n\n    }else{\n      return _.cleanPath(( location.pathname + location.search || \"\" ).replace( this.rRoot, \"/\" ));\n    }\n  },\n\n  nav: function(to, options ){\n\n    var iframe = this.iframe;\n\n    options = options || {};\n\n    to = _.cleanPath(to);\n\n    if(this.curPath == to) return;\n\n    // pushState wont trigger the checkPath\n    // but hashchange will\n    // so we need set curPath before to forbit the CheckPath\n    this.curPath = to;\n\n    // 3 or 1 is matched\n    if( this.mode !== HISTORY ){\n      this._setHash(this.location, to, options.replace);\n      if( iframe && this.getPath(iframe.location) !== to ){\n        if(!options.replace) iframe.document.open().close();\n        this._setHash(this.iframe.location, to, options.replace);\n      }\n    }else{\n      this._changeState(this.location, options.title||\"\", _.cleanPath( this.root + to ), options.replace )\n    }\n\n    if( !options.silent ) this.emit('change', to);\n  },\n  _autolink: function(){\n    if(this.mode!==HISTORY) return;\n    // only in html5 mode, the autolink is works\n    // if(this.mode !== 2) return;\n    var self = this;\n    browser.on( document.body, \"click\", function(ev){\n\n      var target = ev.target || ev.srcElement;\n      if( target.tagName.toLowerCase() !== \"a\" ) return;\n      var tmp = browser.isSameDomain(target.href)&&(browser.getHref(target)||\"\").match(self.rPrefix);\n\n      var hash = tmp && tmp[1]? tmp[1]: \"\";\n\n      if(!hash) return;\n\n      ev.preventDefault && ev.preventDefault();\n      self.nav( hash );\n      return (ev.returnValue = false);\n    } );\n  },\n  _setHash: function(location, path, replace){\n    var href = location.href.replace(/(javascript:|#).*$/, '');\n    if (replace){\n      location.replace(href + this.prefix+ path);\n    }\n    else location.hash = this.prefix+ path;\n  },\n  // for browser that not support onhashchange\n  _checkLoop: function(){\n    var self = this;\n    this.tid = setTimeout( function(){\n      self._checkPath();\n      self._checkLoop();\n    }, this.interval );\n  },\n  // if we use real url in hash env( browser no history popstate support)\n  // or we use hash in html5supoort mode (when paste url in other url)\n  // then , history should repara it\n  _fixInitState: function(){\n    var pathname = _.cleanPath(this.location.pathname), hash, hashInPathName;\n\n    // dont support history popstate but config the html5 mode\n    if( this.mode !== HISTORY && this.html5){\n\n      hashInPathName = pathname.replace(this.rRoot, \"\");\n      if(hashInPathName) this.location.replace(this.root + this.prefix + _.cleanPath(hashInPathName));\n\n    }else if( this.mode === HISTORY /* && pathname === this.root*/){\n\n      hash = this.location.hash.replace(this.prefix, \"\");\n      if(hash) this._changeState( this.location, document.title, _.cleanPath(this.root + hash));\n    }\n  },\n  // ONLY for test, forbid browser to update \n  _changeState: function(location, title, path, replace){\n    var history = location.history || window.history;\n    return history[replace? 'replaceState': 'pushState']({}, title , path)\n  },\n  // Thanks for backbone.history and https://github.com/cowboy/jquery-hashchange/blob/master/jquery.ba-hashchange.js\n  // for helping stateman fixing the oldie hash history issues when with iframe hack\n  _fixHashProbelm: function(path){\n    var iframe = document.createElement('iframe'), body = document.body;\n    iframe.src = 'javascript:;';\n    iframe.style.display = 'none';\n    iframe.tabIndex = -1;\n    iframe.title = \"\";\n    this.iframe = body.insertBefore(iframe, body.firstChild).contentWindow;\n    this.iframe.document.open().close();\n    this.iframe.location.hash = '#' + path;\n  }\n\n});\n\nmodule.exports = History;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/stateman/src/history.js\n ** module id = 7\n ** module chunks = 0\n **/","var win = window,\n    doc = document;\n\nmodule.exports = {\n  hash: \"onhashchange\" in win && (!doc.documentMode || doc.documentMode > 7),\n  history: win.history && \"onpopstate\" in win,\n  location: win.location,\n  isSameDomain: function(url){\n    var matched = url.match(/^.*?:\\/\\/([^/]*)/);\n    if(matched){\n      return matched[0] == this.location.origin;\n    }\n    return true;\n  },\n  getHref: function(node){\n    return \"href\" in node ? node.getAttribute(\"href\", 2) : node.getAttribute(\"href\");\n  },\n  on: \"addEventListener\" in win ?  // IE10 attachEvent is not working when binding the onpopstate, so we need check addEventLister first\n      function(node,type,cb){return node.addEventListener( type, cb )}\n    : function(node,type,cb){return node.attachEvent( \"on\" + type, cb )},\n\n  off: \"removeEventListener\" in win ? \n      function(node,type,cb){return node.removeEventListener( type, cb )}\n    : function(node,type,cb){return node.detachEvent( \"on\" + type, cb )}\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/stateman/src/browser.js\n ** module id = 8\n ** module chunks = 0\n **/","\nvar State = require(\"../state.js\"),\n  _ = require(\"../util.js\"),\n  stateFn = State.prototype.state;\n\nfunction BaseMan( options ){\n\n  options = options || {};\n\n  this._states = {};\n\n  this.strict = options.strict;\n  this.title = options.title;\n\n  if(options.routes) this.state(options.routes);\n\n}\n\n_.extend( _.emitable( BaseMan ), {\n    // keep blank\n    name: '',\n\n    root: true,\n\n\n    state: function(stateName){\n\n      var active = this.active;\n      var args = _.slice(arguments, 1);\n\n      if(typeof stateName === \"string\" && active){\n         stateName = stateName.replace(\"~\", active.name);\n         if(active.parent) stateName = stateName.replace(\"^\", active.parent.name || \"\");\n      }\n      // ^ represent current.parent\n      // ~ represent  current\n      // only \n      args.unshift(stateName);\n      return stateFn.apply(this, args);\n\n    },\n\n    decode: function(path, needLocation){\n\n      var pathAndQuery = path.split(\"?\");\n      var query = this._findQuery(pathAndQuery[1]);\n      path = pathAndQuery[0];\n      var found = this._findState(this, path);\n      if(found) _.extend(found.param, query);\n      return found;\n\n    },\n    encode: function(stateName, param, needLink){\n      var state = this.state(stateName);\n      var history = this.history;\n      if(!state) return;\n      var url  = state.encode(param);\n      \n      return needLink? (history.mode!==2? history.prefix + url : url ): url;\n    },\n    // notify specify state\n    // check the active statename whether to match the passed condition (stateName and param)\n    is: function(stateName, param, isStrict){\n      if(!stateName) return false;\n      stateName = (stateName.name || stateName);\n      var current = this.current, currentName = current.name;\n      var matchPath = isStrict? currentName === stateName : (currentName + \".\").indexOf(stateName + \".\")===0;\n      return matchPath && (!param || _.eql(param, this.param)); \n    },\n\n\n    _wrapPromise: function( promise, next ){\n\n      return promise.then( next, function(){ next(false); }) ;\n\n    },\n\n    _findQuery: function(querystr){\n\n      var queries = querystr && querystr.split(\"&\"), query= {};\n      if(queries){\n        var len = queries.length;\n        for(var i =0; i< len; i++){\n          var tmp = queries[i].split(\"=\");\n          query[tmp[0]] = tmp[1];\n        }\n      }\n      return query;\n\n    },\n    _findState: function(state, path){\n      var states = state._states, found, param;\n\n      // leaf-state has the high priority upon branch-state\n      if(state.hasNext){\n\n        var stateList = _.values( states ).sort( this._sortState );\n        var len = stateList.length;\n\n        for(var i = 0; i < len; i++){\n\n          found = this._findState( stateList[i], path );\n          if( found ) return found;\n        }\n\n      }\n      // in strict mode only leaf can be touched\n      // if all children is don. will try it self\n      param = state.regexp && state.decode(path);\n      if(param){\n        return {\n          state: state,\n          param: param\n        }\n      }else{\n        return false;\n      }\n    },\n    _sortState: function( a, b ){\n      return ( b.priority || 0 ) - ( a.priority || 0 );\n    },\n    // find the same branch;\n    _findBase: function(now, before){\n\n      if(!now || !before || now == this || before == this) return this;\n      var np = now, bp = before, tmp;\n      while(np && bp){\n        tmp = bp;\n        while(tmp){\n          if(np === tmp) return tmp;\n          tmp = tmp.parent;\n        }\n        np = np.parent;\n      }\n    },\n\n}, true);\n\nmodule.exports = BaseMan;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/stateman/src/manager/base.js\n ** module id = 9\n ** module chunks = 0\n **/","\nvar _ = require(\"../util.js\");\nvar Base = require('./base.js');\n\nfunction ServerManager( options ){\n  if(this instanceof ServerManager === false){ return new ServerManager(options); }\n  Base.apply( this, arguments );\n}\n\nvar o =_.inherit( ServerManager, Base.prototype );\n\n_.extend(o , {\n  exec: function ( path ){\n    var found = this.decode(path);\n    if( !found ) return;\n    var param = found.param;\n\n    //@FIXIT: We NEED decodeURIComponent in server side!!\n\n    for(var i in param){\n      if(typeof param[i] === 'string') param[i] = decodeURIComponent(param[i]);\n    }\n    var states = [];\n    var state = found.state;\n    this.current = state;\n\n    while(state && !state.root){\n      states.unshift( state );\n      state = state.parent;\n    }\n\n    return {\n      states: states,\n      param: param\n    }\n  }\n})\n\n\nmodule.exports = ServerManager\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/stateman/src/manager/server.js\n ** module id = 10\n ** module chunks = 0\n **/","\nvar Regular = require('regularjs');\n\nvar util = {\n  isPromiseLike: function (obj){\n    return !!obj && \n      (typeof obj === 'object' || typeof obj === 'function') \n      && typeof obj.then === 'function';\n  },\n  normPromise: function ( ret ){\n    return util.isPromiseLike(ret) ? ret: Promise.resolve(ret)\n  },\n  // if your define second argument, we will automatic generate a promise for you\n  proxyMethod: function( context, method, option ){\n    if(!context) return;\n    var fn = typeof method === 'string'? context[ method ]: method;\n    if(typeof fn === 'function'){\n      if(fn.length >= 2){\n        return new Promise(function(resolve){\n          fn.call(context, option, resolve);\n        })\n      }else{\n        return fn.call(context, option)\n      }\n    }\n  },\n  extend: Regular.util.extend,\n  extractState: (function(){\n    var rStateLink = /^([\\w-]+(?:\\.[\\w-]+)*)\\((.*)\\)$/;\n\n    // app.blog({id:3})\n    return function extractState( stateLinkExpr ){\n      stateLinkExpr = stateLinkExpr.replace(/\\s+/g, '');\n      var parsed = rStateLink.exec(stateLinkExpr);\n      if(parsed){\n        return {\n          name: parsed[1],\n          param: parsed[2]\n        }\n      }\n    }\n  })()\n\n}\n\n\n\n\nmodule.exports = util;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/util.js\n ** module id = 11\n ** module chunks = 0\n **/","var Regular = require('regularjs');\nvar u = require('./util');\nvar extend = u.extend;\nvar win = typeof window !== 'undefined' && window;\n\nvar extension = require('./extension');\n\nfunction createRestate( Stateman ){\n\n  function Restate( options ){\n    options = options || {};\n    if( !(this instanceof Restate)) return new Restate( options );\n    extend(this, options);\n    extension( this);\n    Stateman.call(this, options);\n    \n  }\n\n  var so = Regular.util.createProto(Restate, Stateman.prototype)\n\n  extend(so, {\n    installData: function( option ){\n      var ret,  state = option.state;\n      var firstData = this.firstData;\n\n      if(option.ssr){ //证明首次服务端渲染后的初始化\n        var type = typeof firstData;\n\n        if( type === 'string' ){\n          ret = win[ firstData ][ state.name ];\n        }\n        if(type === 'function'){\n          ret = u.proxyMethod( this, 'firstData', option );\n        }\n      }\n\n      if( ret ) return u.normPromise( ret );\n\n      return u.proxyMethod(state, 'data', option)\n    },\n    installView: function( option ){\n      var  state = option.state ,Comp = state.view;\n      // if(typeof Comp !== 'function') throw Error('view of [' + state.name + '] with wrong type')\n      // Lazy load\n      if(state.ssr === false && Regular.env.node ) {\n        Comp = undefined;\n      } else if( !Regular.isRegular(Comp) ){\n        Comp = u.proxyMethod(state, Comp, option)\n      }\n      return u.normPromise( Comp );\n    },\n    install: function( option ){\n      return Promise.all([this.installData( option ), this.installView( option)]).then(function(ret){\n        return {\n          Component: ret[1],\n          data: ret[0]\n        }\n      })\n    }\n  })\n  return Restate;\n}\n\n\n\n\nmodule.exports = createRestate;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/base.js\n ** module id = 12\n ** module chunks = 0\n **/","var _ = require('./util');\nvar Regular = require('regularjs');\nvar dom = Regular.dom;\n\n\nfunction handleUrl(url, history){\n  return history.mode === 2? url : history.prefix + url\n}\n\nmodule.exports = function( stateman  ){\n\n  function getParam(name, context){\n    if(typeof name !== 'string' || name.toLowerCase().trim() === ''){\n      return null\n    }else{\n      return context.$get(name);\n    }\n  }\n\n  Regular.directive({\n    'r-view': {\n      link: function(element){\n        this.$viewport = element;\n      },\n      ssr: function( attr ){\n        return 'r-view'\n      }\n    },\n    'r-link': {\n      nps: true,\n      link: function(element, value){\n\n        // use html5 history\n        if(stateman.history.mode === 2){\n          dom.attr(element, 'data-autolink', 'data-autolink');\n        }\n        if(value && value.type === 'expression'){\n          \n          this.$watch( value, function( val){\n            dom.attr(element, 'href', \n              handleUrl(\n                val,\n                stateman.history\n              )\n            )\n          })\n          return;\n        }\n        var parsedLinkExpr = _.extractState(value);\n\n        if(parsedLinkExpr){\n\n          var param = parsedLinkExpr.param;\n          if(param.trim() === '' ){\n            value = stateman.encode(parsedLinkExpr.name)\n          }else{\n            this.$watch( parsedLinkExpr.param, function(param){\n              dom.attr(element, 'href', \n                handleUrl(\n                  stateman.encode(parsedLinkExpr.name, param),\n                  stateman.history\n                )\n                \n              )\n            } , {deep: true} )\n            return ;\n          }\n        }\n\n        dom.attr(element, 'href', \n          handleUrl(\n            value,\n            stateman.history\n          )\n        )\n\n          \n      },\n      ssr: function( value, tag ){\n\n        if(value && value.type === 'expression'){\n          return 'href=\"' + Regular.util.escape(getParam(value,this)) +  '\"' \n        }\n        var parsedLinkExpr = _.extractState(value);\n\n        if(parsedLinkExpr){\n          var param = getParam(parsedLinkExpr.param, this);\n          return 'href=\"' + stateman.encode(parsedLinkExpr.name, param)+ '\"' \n        }else{\n        }\n      }\n    }\n  })\n}\n\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/extension.js\n ** module id = 13\n ** module chunks = 0\n **/"],"sourceRoot":""}